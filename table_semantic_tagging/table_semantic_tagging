import re


class ValueRegularizer():
    def __init__(self):
        self.pre_symbol = "(([ \\\\~#\^|:/*;,'!_di-km)][ \\\\~#\^|:</*;,'!_di-km)]*[hJMX \^]*|GFR)*)"
        self.post_symbol = "(([;\^\*%#&$_<\"',. ()\]|\\\\]|[+A-CGTXZa-flmnstwxy])*|[(][a-zR. \-]+[)])"

        self.p_value = "(Interaction)? ?[pP]( value)? ?[=<>]"
        _n_type = "([<>+\-~]|min|max|up to pH|SD|%s|([nr]|rho) ?[ =<>]|T:|$|-50[GT]{,2} = )?" % (self.p_value)
        _number = "0-[0-9]+|[0-9]+-0[0-9]|[0-9 ]*[0-9]-[0-9]|[0-9 ]+[0-9]+-[0-9]{2}|\.?[0-9]"
        _power = "[0-9.'\^][0-9.'\^\-]* ?([xX*] ?10|[Ee])-?[0-9]*"
        _num_w_error = "([0-9lo]|Q-|i[.0-9]|(\.|- ?)[0-9])[ 0-9lOQSf.,':\^]+"
        _numeric = " ?(%s|%s|%s)[*]*" %(_power, _num_w_error, _number)

        _unit1 = "C|%|I ?U(/d)?.*|(mg|mcg|MCU)/[dL]|[mp]?g|[mnp]mol/L|mL/min|kcal/mL|k([jl]|cal)?"
        _unit2 = "[(]IgG[12][)]|P|RAE|HD( and PD)?|PD|py|servings/(week|day).*|days?|[yY]ears|-?months?"
        _unit3 = "sibling/related|unrelated|light|moderate|bar|min|h( oral)?"
        _sex = "(% )?\(?(wo)?men\)?|(fe)?male|[(][MF][)]"
        _etc_unit = "% CM|m?g/dia( TTS)?|mg i\.m\.|/?semanas?|kg( peso)?|% f (fuerza|area|volumen) [a-z0-9 ]+|with( and|out body mass reduction)"
        _unit = "{}|{}|{}|{}|{}".format(_unit1, _unit2, _unit3, _sex, _etc_unit)

        value_pattern0 = "(?P<type{0}>{1})(?P<numeric{0}>{2})(?P<unit{0}>{3})?".format(0, _n_type, _numeric, _unit)
        value_pattern1 = "(?P<type{0}>{1})(?P<numeric{0}>{2})(?P<unit{0}>{3})?".format(1, _n_type, _numeric, _unit)
        value_pattern2 = "(?P<type{0}>{1})(?P<numeric{0}>{2})(?P<unit{0}>{3})?".format(2, _n_type, _numeric, _unit)
        value_pattern3 = "(?P<type{0}>{1})(?P<numeric{0}>{2})(?P<unit{0}>{3})?".format(3, _n_type, _numeric, _unit)
        
        self.p1 = "[(]?(%s)[)]?" %(value_pattern0)
        self.p2 = "[C{(\[]? ?%s ?(?P<separator>to|[\-,/;]| [.6] ) ?%s[)\]]?" %(value_pattern0, value_pattern1)
        self.p3 = "%s ?_?[C({\[]([a-z ]+|%s)[_)\]]" %(value_pattern0, value_pattern1)
        self.p4 = "%s[ ,/;\-]?%s ?[C({\[]([a-z ]+|%s)[)\]]" %(value_pattern0, value_pattern1, value_pattern2)
        self.p5 = "%s ?%s" %(value_pattern2, self.p2)
        self.p6 = "(%s ?){2}" %(self.p2)
        self.p7 = "%s([ ,/;\-]?[(\[]?%s[)\]]? ?){2}" %(value_pattern0, value_pattern1)
        self.p8 = "%s[,;] %s" %(self.p5, value_pattern3)
        self.p9 = "(([FM]|(M|Wom)en):? ?%s ?){2}" %(self.p2)


    def _regularize_numeric(self, n):
        n = n.rstrip('*')
        n = n.replace(' ', '')
        n = re.sub("['':\^]", '.', n)
        n = n.rstrip('.')
        if re.search("[Xx*Ee]", n):
            power_n = re.split("([xX*] ?10|[Ee])", n)
            if len(power_n) == 1 or not power_n[2]:
                return None
            n = float(power_n[0].replace('-', '.')) * (10**int(power_n[2]))
        else:
            n = n.replace('S', '5')
            n = re.sub("[QOo]", '0', n)
            n = re.sub("[|lIi]", '1', n)

            if re.search("^\d{2} ?[\-] ?\d{2,}", n):
                n1, n2 = re.split(" ?[\-] ?", n)
                if int(n1) < int(n2):
                    return None

            n = n.replace('-', '.')
            comma_n = n.split(',')
            if len(comma_n) > 1 and not re.search("^\d{3}[^0-9]*", comma_n[1]):
                return None
            if comma_n[0] == '0' or (len(comma_n) > 2 and len(comma_n[1].split('.')[0]) !=3):
                n = n.replace(',', '.')
            else:
                n = n.replace(',', '')
            n = n.replace("..", '.')
            try:
                n = float(n)
            except ValueError:
                return None
        return n


    def _add_type(self, n_type, value_dic):
        type_dic = {
            "min": "min",
            "max": "max",
            "SD": "SD",
            "<": "less",
            "~": "less or equal",
            ">": "more",
            "": "SD",
            "": "SD"
        }
        unit_dic = {
            "$": "$",
            "T:" : "T"
        }

        if n_type in unit_dic:
            value_dic["unit"] = unit_dic[n_type]
        elif n_type == "up to pH":
            value_dic["type"] = "less or equal"
            value_dic["unit"] = "pH"
        elif n_type.startswith('n'):
            value_dic["unit"] = "count"
        elif n_type.startswith('r'):
            value_dic["unit"] = "rho_value"
        elif re.search("^{}$".format(self.p_value), n_type):
            value_dic["unit"] = "p_value"

        if re.search("[<>]", n_type):
            n_type = re.search("[<>]", n_type)[0]
        if n_type in type_dic:
            value_dic["type"] = type_dic[n_type]
        elif value_dic["value"] != None and value_dic["unit"] != "p_value" and re.search("[\-]", n_type):
            value_dic["value"] *= -1

        return value_dic


    def _extract_info(self, groups, i=0):
        n = self._regularize_numeric(groups.group("numeric{}".format(i)))
        unit = groups.group("unit{}".format(i))
        value_dic = {
            "value": n,
            "unit": unit
        }
        value_dic = self._add_type(groups.group("type{}".format(i)), value_dic)
        return value_dic


    def regularize_value(self, t, count=None):
        t = t.replace("mml/L", "mmol/L")
        t = t.replace("<br>", ' ')

        for i in range(1, 10):
            pattern = "^%s%s%s$" %(self.pre_symbol, eval("self.p{}".format(i)), self.post_symbol)
            groups = re.search(pattern, t)
            comma_splited = t.split(',')
            result = []

            if not groups:
                continue
            elif i == 1:
                comma_splited = t.split(',')
                if ' 6 ' in t or (t.find('-') > 0 and re.search("[,(]", t)) \
                    or ('(' in t and ", " in t) \
                    or count and count > 1:
                    continue

                value_dic = self._extract_info(groups)
                if value_dic["value"] == None:
                    continue
                value_dic["originalCell"] = t
                result.append(value_dic)

                return result
            elif i == 2:
                for i in range(2):
                    value_dic = self._extract_info(groups, i)
                    value_dic["originalCell"] = t
                    result.append(value_dic)

                if any(value_dic["value"] == None for value_dic in result):
                    continue

                sep = groups.group("separator")
                if re.search("[.6]", sep):
                    result[0]["type"] = "mean"
                    result[1]["type"] = "SD"
                elif re.search("(to|[\-])", sep) or (sep == ',' and re.search("[(\[]", t)) \
                    or (result[0].get("type") == "min" and result[1].get("type") == "max"):
                    result[0]["type"] = "range"
                    result[0]["value"] = tuple(r["value"] for r in result)
                    if result[1]["unit"]:
                        result[0]["unit"] = result[1]["unit"]
                    result = result[0]

                return result

            elif i == 3:
                for i in range(2):
                    value_dic = self._extract_info(groups, i)
                    value_dic["originalCell"] = t
                    result.append(value_dic)

                if any(value_dic["value"] == None for value_dic in result):
                    continue

                return result
            elif i == 4:
                for i in range(2):
                    if i == 2 and "numeric2" not in groups.groupdict():
                        break
                    value_dic = self._extract_info(groups, i)
                    value_dic["originalCell"] = t
                    result.append(value_dic)

                if any(value_dic["value"] == None for value_dic in result):
                    continue

                print(t)
                print(result)
                print()
                return result

        return None


if __name__ == "__main__":
    """
    - input: value 문자열 // 희원 주임이 주는 데이터에 따라 input 변경될 수 있음
    - output: 정규화된 value 딕셔너리
    
    참고자료
    <정의된 value 타입> *더 추가될 예정*
    "range"         : "value"에 [최솟값, 최댓값]으로 저장되어 있음.
    "mean           : 평균
    "SD"            : 표준편차
    "less"          : 작음
    "less or equal" : 작거나 같음
    "more"          : 큼
    """
    
    vr = ValueRegularizer()
    print(vr.regularize_value("12"))
    """
    출력 결과
    [
      {
        'value': [1.21, 3.19],
        'unit': None,
        'originalCell': '1.21  3.19',
        'type': 'range'
      }
    ]
    """
